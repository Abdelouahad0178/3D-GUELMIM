<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Immeuble de bureaux R+7 avec RDC commerce - Design réaliste</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      function initOrbitControls(THREE) {
        THREE.OrbitControls = function(camera, domElement) {
          this.camera = camera;
          this.domElement = domElement;
          this.enableDamping = true;
          this.dampingFactor = 0.1;
          this.rotateSpeed = 0.5;
          this.zoomSpeed = 1.0;
          this.panSpeed = 0.5;
          this.target = new THREE.Vector3();
          this.minDistance = 0.5;
          this.maxDistance = 15;
          let scope = this;
          let STATE = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2 };
          let state = STATE.NONE;
          let position0 = new THREE.Vector3();
          let spherical = new THREE.Spherical();
          let sphericalDelta = new THREE.Spherical();
          let scale = 1;
          let panOffset = new THREE.Vector3();
          let rotateStart = new THREE.Vector2();
          let rotateEnd = new THREE.Vector2();
          let rotateDelta = new THREE.Vector2();
          let panStart = new THREE.Vector2();
          let panEnd = new THREE.Vector2();
          let panDelta = new THREE.Vector2();
          let dollyStart = new THREE.Vector2();
          let dollyEnd = new THREE.Vector2();
          let dollyDelta = new THREE.Vector2();
          let touchStart = new THREE.Vector2();
          let touchEnd = new THREE.Vector2();
          let touchDelta = new THREE.Vector2();
          let lastTouchDistance = 0;

          // Gestion des événements de souris (inchangée)
          function onMouseDown(event) {
            event.preventDefault();
            if (event.button === 0) {
              rotateStart.set(event.clientX, event.clientY);
              state = STATE.ROTATE;
            } else if (event.button === 1) {
              dollyStart.set(event.clientX, event.clientY);
              state = STATE.DOLLY;
            } else if (event.button === 2) {
              panStart.set(event.clientX, event.clientY);
              state = STATE.PAN;
            }
            document.addEventListener('mousemove', onMouseMove, false);
            document.addEventListener('mouseup', onMouseUp, false);
          }

          function onMouseMove(event) {
            event.preventDefault();
            if (state === STATE.ROTATE) {
              rotateEnd.set(event.clientX, event.clientY);
              rotateDelta.subVectors(rotateEnd, rotateStart);
              sphericalDelta.theta -= 2 * Math.PI * rotateDelta.x / scope.domElement.clientHeight * scope.rotateSpeed;
              sphericalDelta.phi -= 2 * Math.PI * rotateDelta.y / scope.domElement.clientHeight * scope.rotateSpeed;
              rotateStart.copy(rotateEnd);
              scope.update();
            } else if (state === STATE.DOLLY) {
              dollyEnd.set(event.clientX, event.clientY);
              dollyDelta.subVectors(dollyEnd, dollyStart);
              if (dollyDelta.y > 0) {
                scale *= 0.95;
              } else if (dollyDelta.y < 0) {
                scale *= 1.05;
              }
              dollyStart.copy(dollyEnd);
              scope.update();
            } else if (state === STATE.PAN) {
              panEnd.set(event.clientX, event.clientY);
              panDelta.subVectors(panEnd, panStart);
              panOffset.x -= panDelta.x * 0.01 * scope.panSpeed;
              panOffset.z -= panDelta.y * 0.01 * scope.panSpeed;
              panStart.copy(panEnd);
              scope.update();
            }
          }

          function onMouseUp() {
            document.removeEventListener('mousemove', onMouseMove, false);
            document.removeEventListener('mouseup', onMouseUp, false);
            state = STATE.NONE;
          }

          function onMouseWheel(event) {
            event.preventDefault();
            if (event.deltaY < 0) {
              scale *= 1.1;
            } else {
              scale *= 0.9;
            }
            scope.update();
          }

          // Gestion des événements tactiles
          function onTouchStart(event) {
            event.preventDefault();
            if (event.touches.length === 1) { // Rotation
              touchStart.set(event.touches[0].clientX, event.touches[0].clientY);
              state = STATE.ROTATE;
            } else if (event.touches.length === 2) { // Zoom ou panoramique
              const dx = event.touches[0].clientX - event.touches[1].clientX;
              const dy = event.touches[0].clientY - event.touches[1].clientY;
              lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
              panStart.set(
                (event.touches[0].clientX + event.touches[1].clientX) / 2,
                (event.touches[0].clientY + event.touches[1].clientY) / 2
              );
              state = STATE.DOLLY;
            }
          }

          function onTouchMove(event) {
            event.preventDefault();
            if (state === STATE.ROTATE && event.touches.length === 1) {
              touchEnd.set(event.touches[0].clientX, event.touches[0].clientY);
              touchDelta.subVectors(touchEnd, touchStart);
              sphericalDelta.theta -= 2 * Math.PI * touchDelta.x / scope.domElement.clientHeight * scope.rotateSpeed;
              sphericalDelta.phi -= 2 * Math.PI * touchDelta.y / scope.domElement.clientHeight * scope.rotateSpeed;
              touchStart.copy(touchEnd);
              scope.update();
            } else if (state === STATE.DOLLY && event.touches.length === 2) {
              const dx = event.touches[0].clientX - event.touches[1].clientX;
              const dy = event.touches[0].clientY - event.touches[1].clientY;
              const distance = Math.sqrt(dx * dx + dy * dy);
              panEnd.set(
                (event.touches[0].clientX + event.touches[1].clientX) / 2,
                (event.touches[0].clientY + event.touches[1].clientY) / 2
              );
              panDelta.subVectors(panEnd, panStart);
              if (lastTouchDistance > 0) {
                scale *= (lastTouchDistance / distance);
                panOffset.x -= panDelta.x * 0.01 * scope.panSpeed;
                panOffset.z -= panDelta.y * 0.01 * scope.panSpeed;
              }
              lastTouchDistance = distance;
              panStart.copy(panEnd);
              scope.update();
            }
          }

          function onTouchEnd() {
            state = STATE.NONE;
            lastTouchDistance = 0;
          }

          this.domElement.addEventListener('mousedown', onMouseDown, false);
          this.domElement.addEventListener('wheel', onMouseWheel, false);
          this.domElement.addEventListener('contextmenu', function(event) { event.preventDefault(); }, false);
          this.domElement.addEventListener('touchstart', onTouchStart, false);
          this.domElement.addEventListener('touchmove', onTouchMove, false);
          this.domElement.addEventListener('touchend', onTouchEnd, false);

          this.update = function() {
            let offset = new THREE.Vector3();
            position0.copy(this.camera.position).sub(this.target);
            spherical.setFromVector3(position0);
            spherical.theta += sphericalDelta.theta;
            spherical.phi += sphericalDelta.phi;
            spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
            spherical.radius *= scale;
            spherical.radius = Math.max(this.minDistance, Math.min(this.maxDistance, spherical.radius));
            offset.setFromSpherical(spherical);
            offset.add(panOffset);
            this.camera.position.copy(this.target).add(offset);
            this.camera.lookAt(this.target);
            sphericalDelta.set(0, 0, 0);
            panOffset.set(0, 0, 0);
            scale = 1;
            return true;
          };
        };
        init3DModel();
      }
      initOrbitControls(THREE);
    });
  </script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
      background: linear-gradient(to bottom, #1e5799, #7db9e8);
    }
    canvas {
      display: block;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      background-color: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 5px;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      max-width: 300px;
    }
    #controls {
      position: absolute;
      bottom: 10px;
      left: 10px;
      color: white;
      background-color: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 5px;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    #officeButton {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: #4fc3f7;
      color: white;
      padding: 10px 20px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      font-size: 16px;
    }
    #officeButton:hover {
      background-color: #0288d1;
    }
    h2 {
      margin-top: 0;
      color: #4fc3f7;
    }
  </style>
</head>
<body>
  <div id="info">
    <h2>Immeuble de bureaux R+7</h2>
    
  </div>
  <div id="controls">
   
  </div>
  <button id="officeButton">Visiter le bureau</button>

  <script>
    const ETAGE_HEIGHT = 3;
    const BUILDING_WIDTH = 9;
    const BUILDING_LENGTH = 49;
    const ETAGE_COUNT = 8;

    function init3DModel() {
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB);
      
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(40, 25, 40);
      
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);
      
      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.1;
      controls.minDistance = 0.5;
      controls.maxDistance = 15;
      
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(20, 30, 20);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 1024;
      directionalLight.shadow.mapSize.height = 1024;
      scene.add(directionalLight);
      
      const spotLight = new THREE.SpotLight(0xffffff, 0.5);
      spotLight.position.set(-20, 40, -20);
      spotLight.castShadow = true;
      scene.add(spotLight);

      const groundSize = 200;
      const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize);
      const groundMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x228B22,
        roughness: 0.8,
        metalness: 0.2
      });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = -0.1;
      ground.receiveShadow = true;
      scene.add(ground);
      
      const roadWidth = 10;
      const roadMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
      const frontRoadGeometry = new THREE.PlaneGeometry(BUILDING_WIDTH + roadWidth * 2, roadWidth);
      const frontRoad = new THREE.Mesh(frontRoadGeometry, roadMaterial);
      frontRoad.rotation.x = -Math.PI / 2;
      frontRoad.position.set(0, 0, BUILDING_LENGTH / 2 + roadWidth / 2);
      scene.add(frontRoad);
      
      const leftRoadGeometry = new THREE.PlaneGeometry(roadWidth, BUILDING_LENGTH);
      const leftRoad = new THREE.Mesh(leftRoadGeometry, roadMaterial);
      leftRoad.rotation.x = -Math.PI / 2;
      leftRoad.position.set(-BUILDING_WIDTH / 2 - roadWidth / 2, 0, 0);
      scene.add(leftRoad);

      const buildingMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xEEEEEE, 
        roughness: 0.3,
        metalness: 0.2
      });
      
      const glassMaterial = new THREE.MeshPhysicalMaterial({ 
        color: 0x1E88E5, // Vitres bleues
        transparent: true, 
        opacity: 0.5,
        roughness: 0.1, 
        metalness: 0.9,
        reflectivity: 1.0,
        clearcoat: 1.0,
        clearcoatRoughness: 0.1
      });
      
      const doorMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x8B4513, 
        roughness: 0.5, 
        metalness: 0.3 
      });
      
      const shutterMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x9E9E9E,
        roughness: 0.4,
        metalness: 0.8
      });
      
      const corridorMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xE0E0E0,
        roughness: 0.3
      });
      
      const officeDoorMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x795548,
        roughness: 0.5
      });
      
      const bathroomDoorMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xD2B48C, // Beige clair pour la porte du WC
        roughness: 0.5,
        metalness: 0.3
      });
      
      const frameMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x424242,
        roughness: 0.3,
        metalness: 0.7
      });

      const wallMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xF5F5F5,
        roughness: 0.3,
        metalness: 0.1
      });

      const marbleMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xE5E5E5,
        roughness: 0.2,
        metalness: 0.1
      });

      const woodMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x8B4513,
        roughness: 0.5,
        metalness: 0.3
      });

      const gridMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xD3D3D3,
        roughness: 0.5,
        metalness: 0.2
      });

      const sofaMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xB0B0B0,
        roughness: 0.7,
        metalness: 0.1
      });

      const cushionMaterial1 = new THREE.MeshStandardMaterial({ 
        color: 0xF5F5DC,
        roughness: 0.7,
        metalness: 0.1
      });

      const cushionMaterial2 = new THREE.MeshStandardMaterial({ 
        color: 0xFFFFFF,
        roughness: 0.7,
        metalness: 0.1
      });

      const cushionMaterial3 = new THREE.MeshStandardMaterial({ 
        color: 0x808080,
        roughness: 0.7,
        metalness: 0.1
      });

      const chairMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xFFFFFF,
        roughness: 0.5,
        metalness: 0.1
      });

      const cushionMaterial4 = new THREE.MeshStandardMaterial({ 
        color: 0x333333,
        roughness: 0.7,
        metalness: 0.1
      });

      const rugMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xF5F5F5,
        roughness: 0.8,
        metalness: 0.1
      });

      const tableMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x1C2526,
        roughness: 0.3,
        metalness: 0.8
      });

      const vaseMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xFFFFFF,
        roughness: 0.2,
        metalness: 0.1
      });

      const flowersMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xFFFFE0,
        roughness: 0.7,
        metalness: 0.1
      });

      const deskMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xD2B48C,
        roughness: 0.5,
        metalness: 0.3
      });

      const deskBaseMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x1C2526,
        roughness: 0.3,
        metalness: 0.8
      });

      const computerMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xD3D3D3,
        roughness: 0.3,
        metalness: 0.9
      });

      const officeChairMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x8B4513,
        roughness: 0.5,
        metalness: 0.3
      });

      const toiletMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xFFFFFF,
        roughness: 0.2,
        metalness: 0.1
      });

      let officeGroup = null;
      let buildingGroup = null;

      function createBuilding() {
        const building = new THREE.Group();
        buildingGroup = building;
        
        for (let i = 0; i < ETAGE_COUNT; i++) {
          const etageGeometry = new THREE.BoxGeometry(BUILDING_WIDTH, ETAGE_HEIGHT, BUILDING_LENGTH);
          const etage = new THREE.Mesh(etageGeometry, buildingMaterial);
          etage.position.y = i * ETAGE_HEIGHT + ETAGE_HEIGHT / 2;
          etage.castShadow = true;
          etage.receiveShadow = true;
          building.add(etage);
          
          if (i === 0) {
            addRdcDetails(etage);
          } else {
            addOfficeDetails(etage, i);
          }
        }
        
        addRoofDetails(building, ETAGE_COUNT * ETAGE_HEIGHT);
        scene.add(building);
      }

      function addRdcDetails(etage) {
        const doorWidth = 2;
        const doorHeight = 2.5;
        const doorGeometry = new THREE.BoxGeometry(doorWidth, doorHeight, 0.2);
        const door = new THREE.Mesh(doorGeometry, doorMaterial);
        door.position.set(BUILDING_WIDTH / 2 - doorWidth / 2, -0.25, BUILDING_LENGTH / 2 + 0.1);
        etage.add(door);
        
        const doorFrameGeometry = new THREE.BoxGeometry(doorWidth + 0.4, doorHeight + 0.4, 0.1);
        const doorFrame = new THREE.Mesh(doorFrameGeometry, frameMaterial);
        doorFrame.position.set(BUILDING_WIDTH / 2 - doorWidth / 2, -0.25, BUILDING_LENGTH / 2 + 0.05);
        etage.add(doorFrame);
        
        const shutterWidth = (BUILDING_WIDTH - doorWidth) / 2;
        for (let i = 0; i < 2; i++) {
          const shutterGeometry = new THREE.BoxGeometry(shutterWidth, 2.5, 0.1);
          const shutter = new THREE.Mesh(shutterGeometry, shutterMaterial);
          shutter.position.set(
            -BUILDING_WIDTH / 2 + shutterWidth / 2 + i * shutterWidth,
            -0.25,
            BUILDING_LENGTH / 2 + 0.1
          );
          etage.add(shutter);
        }
        
        const shutterSideWidth = BUILDING_LENGTH / 10;
        for (let i = 0; i < 10; i++) {
          const shutterGeometry = new THREE.BoxGeometry(0.1, 2.5, shutterSideWidth - 0.2);
          const shutter = new THREE.Mesh(shutterGeometry, shutterMaterial);
          shutter.position.set(
            -BUILDING_WIDTH / 2 - 0.1,
            -0.25,
            BUILDING_LENGTH / 2 - shutterSideWidth / 2 - i * shutterSideWidth
          );
          etage.add(shutter);
        }
      }

      function addOfficeDetails(etage, etageNumber) {
        const windowHeight = ETAGE_HEIGHT * 0.7;
        const windowCount = 10;
        const windowWidth = BUILDING_LENGTH / windowCount;
        
        for (let i = 0; i < windowCount; i++) {
          const windowGeometry = new THREE.BoxGeometry(0.1, windowHeight, windowWidth - 0.5);
          const window = new THREE.Mesh(windowGeometry, glassMaterial);
          window.position.set(
            -BUILDING_WIDTH / 2 - 0.1,
            0,
            BUILDING_LENGTH / 2 - windowWidth / 2 - i * windowWidth
          );
          etage.add(window);
          
          const frameGeometry = new THREE.BoxGeometry(0.15, windowHeight + 0.2, windowWidth - 0.3);
          const frame = new THREE.Mesh(frameGeometry, frameMaterial);
          frame.position.set(
            -BUILDING_WIDTH / 2 - 0.05,
            0,
            BUILDING_LENGTH / 2 - windowWidth / 2 - i * windowWidth
          );
          etage.add(frame);
        }
        
        const frontWindowCount = 4;
        const frontWindowWidth = BUILDING_WIDTH / frontWindowCount;
        
        for (let i = 0; i < frontWindowCount; i++) {
          const frontWindowGeometry = new THREE.BoxGeometry(frontWindowWidth - 0.3, windowHeight, 0.1);
          const frontWindow = new THREE.Mesh(frontWindowGeometry, glassMaterial);
          frontWindow.position.set(
            -BUILDING_WIDTH / 2 + frontWindowWidth / 2 + i * frontWindowWidth,
            0,
            BUILDING_LENGTH / 2 + 0.1
          );
          etage.add(frontWindow);
          
          const frontFrameGeometry = new THREE.BoxGeometry(frontWindowWidth - 0.1, windowHeight + 0.2, 0.15);
          const frontFrame = new THREE.Mesh(frontFrameGeometry, frameMaterial);
          frontFrame.position.set(
            -BUILDING_WIDTH / 2 + frontWindowWidth / 2 + i * frontWindowWidth,
            0,
            BUILDING_LENGTH / 2 + 0.05
          );
          etage.add(frontFrame);
        }
        
        const corridorGeometry = new THREE.BoxGeometry(1.5, ETAGE_HEIGHT - 0.2, BUILDING_LENGTH - 1);
        const corridor = new THREE.Mesh(corridorGeometry, corridorMaterial);
        corridor.position.set(0, 0, -0.5);
        etage.add(corridor);
        
        const officeCount = 8;
        const officeLength = (BUILDING_LENGTH - 1) / (officeCount / 2);
        
        for (let i = 0; i < officeCount / 2; i++) {
          const leftDoorGeometry = new THREE.BoxGeometry(0.1, 2, 1);
          const leftDoor = new THREE.Mesh(leftDoorGeometry, officeDoorMaterial);
          leftDoor.position.set(-0.75, -0.5, BUILDING_LENGTH / 2 - 2 - i * officeLength);
          etage.add(leftDoor);
          
          const leftFrameGeometry = new THREE.BoxGeometry(0.15, 2.1, 1.1);
          const leftFrame = new THREE.Mesh(leftFrameGeometry, frameMaterial);
          leftFrame.position.set(-0.725, -0.5, BUILDING_LENGTH / 2 - 2 - i * officeLength);
          etage.add(leftFrame);
          
          const rightDoorGeometry = new THREE.BoxGeometry(0.1, 2, 1);
          const rightDoor = new THREE.Mesh(rightDoorGeometry, officeDoorMaterial);
          rightDoor.position.set(0.75, -0.5, BUILDING_LENGTH / 2 - 2 - i * officeLength);
          etage.add(rightDoor);
          
          const rightFrameGeometry = new THREE.BoxGeometry(0.15, 2.1, 1.1);
          const rightFrame = new THREE.Mesh(rightFrameGeometry, frameMaterial);
          rightFrame.position.set(0.725, -0.5, BUILDING_LENGTH / 2 - 2 - i * officeLength);
          etage.add(rightFrame);
        }
        
        const stairGeometry = new THREE.BoxGeometry(1.5, ETAGE_HEIGHT - 0.2, 3);
        const stairMaterial = new THREE.MeshStandardMaterial({ 
          color: 0x607D8B,
          roughness: 0.6,
          metalness: 0.2
        });
        const stair = new THREE.Mesh(stairGeometry, stairMaterial);
        stair.position.set(0, 0, BUILDING_LENGTH / 2 - 1.5);
        etage.add(stair);
      }
      
      function addRoofDetails(building, topHeight) {
        const roofStructureGeometry = new THREE.BoxGeometry(4, 2, 4);
        const roofStructureMaterial = new THREE.MeshStandardMaterial({ 
          color: 0x424242,
          roughness: 0.5,
          metalness: 0.3
        });
        const roofStructure = new THREE.Mesh(roofStructureGeometry, roofStructureMaterial);
        roofStructure.position.set(0, topHeight + 1, 0);
        roofStructure.castShadow = true;
        building.add(roofStructure);
        
        const antennaGeometry = new THREE.CylinderGeometry(0.05, 0.05, 3, 8);
        const antennaMaterial = new THREE.MeshStandardMaterial({ 
          color: 0x9E9E9E,
          roughness: 0.3,
          metalness: 0.9
        });
        
        const antenna1 = new THREE.Mesh(antennaGeometry, antennaMaterial);
        antenna1.position.set(-1, topHeight + 3.5, -1);
        building.add(antenna1);
        
        const antenna2 = new THREE.Mesh(antennaGeometry, antennaMaterial);
        antenna2.position.set(1, topHeight + 3, 1);
        building.add(antenna2);
        
        const roofEdgeGeometry = new THREE.BoxGeometry(BUILDING_WIDTH + 0.5, 0.3, BUILDING_LENGTH + 0.5);
        const roofEdgeMaterial = new THREE.MeshStandardMaterial({ 
          color: 0x757575,
          roughness: 0.5,
          metalness: 0.3
        });
        const roofEdge = new THREE.Mesh(roofEdgeGeometry, roofEdgeMaterial);
        roofEdge.position.set(0, topHeight + 0.15, 0);
        building.add(roofEdge);
      }

      createBuilding();
      
      function addEnvironmentDetails() {
        const treeCount = 8;
        for (let i = 0; i < treeCount; i++) {
          const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.4, 2, 8);
          const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8D6E63 });
          const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
          
          const leavesGeometry = new THREE.ConeGeometry(1.5, 3, 8);
          const leavesMaterial = new THREE.MeshStandardMaterial({ color: 0x2E7D32 });
          const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
          leaves.position.y = 2.5;
          
          const tree = new THREE.Group();
          tree.add(trunk);
          tree.add(leaves);
          
          const angle = (i / treeCount) * Math.PI * 2;
          const radius = 30;
          const x = Math.cos(angle) * radius;
          let z = Math.sin(angle) * radius;
          
          if (z > BUILDING_LENGTH / 2 - 10) {
            z += 15;
          }
          
          tree.position.set(x, 0, z);
          tree.castShadow = true;
          scene.add(tree);
        }
        
        for (let i = 0; i < 2; i++) {
          const benchGeometry = new THREE.BoxGeometry(2, 0.4, 0.8);
          const benchMaterial = new THREE.MeshStandardMaterial({ color: 0x795548 });
          const bench = new THREE.Mesh(benchGeometry, benchMaterial);
          
          const legGeometry = new THREE.BoxGeometry(0.1, 0.4, 0.6);
          const legMaterial = new THREE.MeshStandardMaterial({ color: 0x5D4037 });
          
          const leg1 = new THREE.Mesh(legGeometry, legMaterial);
          leg1.position.set(-0.8, -0.4, 0);
          bench.add(leg1);
          
          const leg2 = new THREE.Mesh(legGeometry, legMaterial);
          leg2.position.set(0.8, -0.4, 0);
          bench.add(leg2);
          
          bench.position.set(i === 0 ? -15 : 15, 0.4, BUILDING_LENGTH / 2 + 5);
          bench.castShadow = true;
          scene.add(bench);
        }
      }

      addEnvironmentDetails();

      function createOffice() {
        if (officeGroup) {
          scene.remove(officeGroup);
          officeGroup = null;
          scene.add(buildingGroup);
          camera.position.set(40, 25, 40);
          controls.target.set(0, 10, 0);
          controls.minDistance = 0.5;
          controls.maxDistance = 100;
          controls.enabled = true;
          return;
        }
        
        scene.remove(buildingGroup);
        officeGroup = new THREE.Group();
        
        const officeWidth = 6; // Largeur (mur avec porte)
        const officeDepth = 7; // Longueur
        const officeHeight = ETAGE_HEIGHT;
        
        // Sol (béton poli gris foncé)
        const floorGeometry = new THREE.PlaneGeometry(officeWidth, officeDepth);
        const floorMaterial = new THREE.MeshStandardMaterial({ 
          color: 0x808080,
          roughness: 0.3,
          metalness: 0.2
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        officeGroup.add(floor);
        
        // Plafond
        const ceilingGeometry = new THREE.PlaneGeometry(officeWidth, officeDepth);
        const ceilingMaterial = new THREE.MeshStandardMaterial({ 
          color: 0xD3D3D3,
          roughness: 0.5,
          metalness: 0.1
        });
        const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
        ceiling.rotation.x = Math.PI / 2;
        ceiling.position.set(0, officeHeight, 0);
        officeGroup.add(ceiling);
        
        // Mur arrière (avec porte à droite)
        const backWallGeometry = new THREE.BoxGeometry(officeWidth, officeHeight, 0.2);
        const backWall = new THREE.Mesh(backWallGeometry, wallMaterial);
        backWall.position.set(0, officeHeight / 2, -officeDepth / 2);
        officeGroup.add(backWall);
        
        // Porte d'entrée (à droite, s'ouvre vers l'extérieur)
        const doorWidth = 0.9;
        const doorGeometry = new THREE.BoxGeometry(doorWidth, 2.1, 0.1);
        const door = new THREE.Mesh(doorGeometry, officeDoorMaterial);
        door.position.set(officeWidth / 2 - doorWidth / 2 - 0.5, 1.05, -officeDepth / 2 - 0.2);
        officeGroup.add(door);
        
        // Cadre de la porte pour la rendre visible
        const doorFrameGeometry = new THREE.BoxGeometry(doorWidth + 0.2, 2.3, 0.15);
        const doorFrame = new THREE.Mesh(doorFrameGeometry, frameMaterial);
        doorFrame.position.set(officeWidth / 2 - doorWidth / 2 - 0.5, 1.05, -officeDepth / 2);
        officeGroup.add(doorFrame);
        
        // WC (à gauche en entrant, 1.5m x 2m = 3m²)
        const bathroomWidth = 1.5;
        const bathroomDepth = 2;
        const bathroomFloorGeometry = new THREE.PlaneGeometry(bathroomWidth, bathroomDepth);
        const bathroomFloor = new THREE.Mesh(bathroomFloorGeometry, floorMaterial);
        bathroomFloor.rotation.x = -Math.PI / 2;
        bathroomFloor.position.set(-officeWidth / 2 + bathroomWidth / 2, 0, -officeDepth / 2 + bathroomDepth / 2);
        officeGroup.add(bathroomFloor);
        
        // Mur droit du WC
        const bathroomRightWallGeometry = new THREE.BoxGeometry(0.2, officeHeight, bathroomDepth);
        const bathroomRightWall = new THREE.Mesh(bathroomRightWallGeometry, wallMaterial);
        bathroomRightWall.position.set(-officeWidth / 2 + bathroomWidth, officeHeight / 2, -officeDepth / 2 + bathroomDepth / 2);
        officeGroup.add(bathroomRightWall);
        
        // Mur avant du WC (avec porte)
        const bathroomFrontWallGeometry = new THREE.BoxGeometry(bathroomWidth, officeHeight, 0.2);
        const bathroomFrontWall = new THREE.Mesh(bathroomFrontWallGeometry, wallMaterial);
        bathroomFrontWall.position.set(-officeWidth / 2 + bathroomWidth / 2, officeHeight / 2, -officeDepth / 2 + bathroomDepth);
        officeGroup.add(bathroomFrontWall);
        
        // Mur arrière du WC
        const bathroomBackWallGeometry = new THREE.BoxGeometry(bathroomWidth, officeHeight, 0.2);
        const bathroomBackWall = new THREE.Mesh(bathroomBackWallGeometry, wallMaterial);
        bathroomBackWall.position.set(-officeWidth / 2 + bathroomWidth / 2, officeHeight / 2, -officeDepth / 2);
        officeGroup.add(bathroomBackWall);
        
        // Mur gauche du WC
        const bathroomLeftWallGeometry = new THREE.BoxGeometry(0.2, officeHeight, bathroomDepth);
        const bathroomLeftWall = new THREE.Mesh(bathroomLeftWallGeometry, wallMaterial);
        bathroomLeftWall.position.set(-officeWidth / 2, officeHeight / 2, -officeDepth / 2 + bathroomDepth / 2);
        officeGroup.add(bathroomLeftWall);
        
        // Porte du WC (sur le mur avant du WC, déplacée plus vers l'intérieur)
        const bathroomDoorGeometry = new THREE.BoxGeometry(bathroomWidth - 0.7, 2.1, 0.1);
        const bathroomDoor = new THREE.Mesh(bathroomDoorGeometry, bathroomDoorMaterial);
        bathroomDoor.position.set(-officeWidth / 2 + bathroomWidth / 2, 1.05, -officeDepth / 2 + bathroomDepth - 0.3);
        officeGroup.add(bathroomDoor);
        
        // Cadre de la porte du WC
        const bathroomDoorFrameGeometry = new THREE.BoxGeometry(bathroomWidth - 0.5, 2.3, 0.2);
        const bathroomDoorFrame = new THREE.Mesh(bathroomDoorFrameGeometry, frameMaterial);
        bathroomDoorFrame.position.set(-officeWidth / 2 + bathroomWidth / 2, 1.05, -officeDepth / 2 + bathroomDepth);
        officeGroup.add(bathroomDoorFrame);
        
        // Équipements WC (toilette + lavabo)
        const toiletGeometry = new THREE.BoxGeometry(0.4, 0.6, 0.6);
        const toilet = new THREE.Mesh(toiletGeometry, toiletMaterial);
        toilet.position.set(-officeWidth / 2 + bathroomWidth - 0.5, 0.3, -officeDepth / 2 + 0.5);
        officeGroup.add(toilet);
        
        const sinkGeometry = new THREE.BoxGeometry(0.6, 0.4, 0.4);
        const sink = new THREE.Mesh(sinkGeometry, toiletMaterial);
        sink.position.set(-officeWidth / 2 + bathroomWidth / 2, 0.2, -officeDepth / 2 + 1.5);
        officeGroup.add(sink);
        
        // Mur avant (remplacé par une grande vitre bleue)
        const fullWindowGeometry = new THREE.BoxGeometry(officeWidth, officeHeight - 0.2, 0.1);
        const fullWindow = new THREE.Mesh(fullWindowGeometry, glassMaterial);
        fullWindow.position.set(0, officeHeight / 2, officeDepth / 2 + 0.05);
        officeGroup.add(fullWindow);
        
        // Stores (partiellement baissés, ajustés pour la grande vitre)
        const blindGeometry = new THREE.BoxGeometry(officeWidth, officeHeight / 2, 0.05);
        const blindMaterial = new THREE.MeshStandardMaterial({ 
          color: 0xF5F5DC,
          roughness: 0.7,
          metalness: 0.1
        });
        const blind = new THREE.Mesh(blindGeometry, blindMaterial);
        blind.position.set(0, officeHeight * 3 / 4, officeDepth / 2);
        officeGroup.add(blind);
        
        // Mur gauche (marbre avec bande en bois, après le WC)
        const leftWallGeometry = new THREE.BoxGeometry(0.2, officeHeight, officeDepth - bathroomDepth);
        const leftWall = new THREE.Mesh(leftWallGeometry, marbleMaterial);
        leftWall.position.set(-officeWidth / 2, officeHeight / 2, bathroomDepth / 2);
        officeGroup.add(leftWall);
        
        const woodStripGeometry = new THREE.BoxGeometry(0.1, officeHeight, 1);
        const woodStrip = new THREE.Mesh(woodStripGeometry, woodMaterial);
        woodStrip.position.set(-officeWidth / 2 - 0.05, officeHeight / 2, -officeDepth / 2 + bathroomDepth + 0.5);
        officeGroup.add(woodStrip);
        
        // Mur droit (avec grille décorative)
        const rightWallGeometry = new THREE.BoxGeometry(0.2, officeHeight, officeDepth);
        const rightWall = new THREE.Mesh(rightWallGeometry, wallMaterial);
        rightWall.position.set(officeWidth / 2, officeHeight / 2, 0);
        officeGroup.add(rightWall);
        
        const gridGeometry = new THREE.BoxGeometry(0.1, officeHeight - 0.4, officeDepth - 0.4);
        const grid = new THREE.Mesh(gridGeometry, gridMaterial);
        grid.position.set(officeWidth / 2 + 0.05, officeHeight / 2, 0);
        officeGroup.add(grid);
        
        // Tapis (motifs losanges, ajusté aux dimensions)
        const rugGeometry = new THREE.PlaneGeometry(4, 3);
        const rug = new THREE.Mesh(rugGeometry, rugMaterial);
        rug.rotation.x = -Math.PI / 2;
        rug.position.set(0, 0.01, 0);
        officeGroup.add(rug);
        
        // Canapé (à gauche, après le WC)
        const sofaGeometry = new THREE.BoxGeometry(2.5, 0.8, 1.2);
        const sofa = new THREE.Mesh(sofaGeometry, sofaMaterial);
        sofa.position.set(-officeWidth / 2 + bathroomWidth + 1.25, 0.4, 0);
        officeGroup.add(sofa);
        
        // Coussins sur le canapé
        const cushionGeometry = new THREE.BoxGeometry(0.6, 0.6, 0.6);
        const cushion1 = new THREE.Mesh(cushionGeometry, cushionMaterial1);
        cushion1.position.set(-officeWidth / 2 + bathroomWidth + 0.65, 0.7, 0);
        officeGroup.add(cushion1);
        
        const cushion2 = new THREE.Mesh(cushionGeometry, cushionMaterial2);
        cushion2.position.set(-officeWidth / 2 + bathroomWidth + 1.25, 0.7, 0);
        officeGroup.add(cushion2);
        
        const cushion3 = new THREE.Mesh(cushionGeometry, cushionMaterial3);
        cushion3.position.set(-officeWidth / 2 + bathroomWidth + 1.85, 0.7, 0);
        officeGroup.add(cushion3);
        
        // Chaise d'appoint (près des fenêtres)
        const chairGeometry = new THREE.BoxGeometry(1, 1, 1);
        const chair = new THREE.Mesh(chairGeometry, chairMaterial);
        chair.position.set(0, 0.5, officeDepth / 2 - 0.5);
        officeGroup.add(chair);
        
        const cushion4 = new THREE.Mesh(cushionGeometry, cushionMaterial4);
        cushion4.position.set(0, 0.8, officeDepth / 2 - 0.5);
        officeGroup.add(cushion4);
        
        // Table basse (sur le tapis)
        const tableGeometry = new THREE.BoxGeometry(1.2, 0.4, 0.8);
        const table = new THREE.Mesh(tableGeometry, tableMaterial);
        table.position.set(0, 0.2, 0);
        officeGroup.add(table);
        
        // Vase avec fleurs
        const vaseGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.3, 16);
        const vase = new THREE.Mesh(vaseGeometry, vaseMaterial);
        vase.position.set(0, 0.45, 0);
        officeGroup.add(vase);
        
        const flowersGeometry = new THREE.SphereGeometry(0.2, 16, 16);
        const flowers = new THREE.Mesh(flowersGeometry, flowersMaterial);
        flowers.position.set(0, 0.65, 0);
        officeGroup.add(flowers);
        
        // Bureau (à droite, près des fenêtres)
        const deskBaseGeometry = new THREE.BoxGeometry(0.8, 0.75, 1.2);
        const deskBase = new THREE.Mesh(deskBaseGeometry, deskBaseMaterial);
        deskBase.position.set(officeWidth / 2 - 0.8, 0.375, officeDepth / 2 - 0.6);
        officeGroup.add(deskBase);
        
        const deskTopGeometry = new THREE.BoxGeometry(1.5, 0.1, 1.2);
        const deskTop = new THREE.Mesh(deskTopGeometry, deskMaterial);
        deskTop.position.set(officeWidth / 2 - 0.8, 0.8, officeDepth / 2 - 0.6);
        officeGroup.add(deskTop);
        
        // Ordinateur sur le bureau
        const computerGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.1);
        const computer = new THREE.Mesh(computerGeometry, computerMaterial);
        computer.position.set(officeWidth / 2 - 0.8, 1, officeDepth / 2 - 0.6);
        officeGroup.add(computer);
        
        // Chaise de bureau
        const officeChairGeometry = new THREE.BoxGeometry(0.6, 1.2, 0.6);
        const officeChair = new THREE.Mesh(officeChairGeometry, officeChairMaterial);
        officeChair.position.set(officeWidth / 2 - 0.8, 0.6, officeDepth / 2 - 1.5);
        officeGroup.add(officeChair);
        
        officeGroup.position.set(0, 0.1, 0);
        scene.add(officeGroup);
        
        // Configuration pour visite virtuelle
        camera.position.set(officeWidth / 2 - 1, 1.6, -officeDepth / 2 + 1);
        controls.target.set(0, 1.6, 0);
        controls.minDistance = 0.5;
        controls.maxDistance = 10;
        controls.enablePan = true;
        controls.enableRotate = true;
        controls.enableZoom = true;
        controls.update();
      }

      const officeButton = document.getElementById('officeButton');
      officeButton.addEventListener('click', () => {
        createOffice();
        officeButton.textContent = officeGroup ? 'Retour au bâtiment' : 'Visiter le bureau';
      });

      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }
      animate();

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }
  </script>
</body>
</html>